/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 * @format
 */

'use strict';

import type {SchemaType, NativeModuleShape} from '../../CodegenSchema';

const {capitalizeFirstLetter} = require('./ObjCppUtils/GenerateStructs');
const {flatObjects} = require('./ObjCppUtils/Utils');
const {getTypeAliasTypeAnnotation} = require('./Utils');

type FilesOutput = Map<string, string>;

const propertyHeaderTemplate =
  '    static facebook::jsi::Value __hostFunction_Native::_MODULE_NAME_::SpecJSI_::_PROPERTY_NAME_::(facebook::jsi::Runtime& rt, TurboModule &turboModule, const facebook::jsi::Value* args, size_t count) {';

const propertyCastTemplate = `static_cast<ObjCTurboModule &>(turboModule)
         .invokeObjCMethod(rt, ::_KIND_::, "::_PROPERTY_NAME_::", @selector(::_PROPERTY_NAME_::::_ARGS_::), args, count);`;

const propertyTemplate = `
${propertyHeaderTemplate}
      return ${propertyCastTemplate}
    }`;

const propertyDefTemplate =
  '      methodMap_["::_PROPERTY_NAME_::"] = MethodMetadata {::_ARGS_COUNT_::, __hostFunction_Native::_MODULE_NAME_::SpecJSI_::_PROPERTY_NAME_::};';

const moduleTemplate = `
    ::_TURBOMODULE_METHOD_INVOKERS_::

    Native::_MODULE_NAME_::SpecJSI::Native::_MODULE_NAME_::SpecJSI(const ObjCTurboModule::InitParams &params)
      : ObjCTurboModule(params) {
    ::_PROPERTIES_MAP_::::_CONVERSION_SELECTORS_::
    }`.trim();

const getterTemplate = `
@implementation RCTCxxConvert (Native::_MODULE_NAME_::_::_GETTER_NAME_::)
+ (RCTManagedPointer *)JS_Native::_MODULE_NAME_::_::_GETTER_NAME_:::(id)json
{
  return facebook::react::managedPointer<JS::Native::_MODULE_NAME_::::::_GETTER_NAME_::>(json);
}
@end
`;

const argConvertionTemplate =
  '\n      setMethodArgConversionSelector(@"::_ARG_NAME_::", ::_ARG_NUMBER_::, @"JS_Native::_MODULE_NAME_::_::_SELECTOR_NAME_:::");';

const template = `
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * ${'@'}generated by codegen project: GenerateModuleMm.js
 */

#include <::_INCLUDE_::>
#import <folly/Optional.h>

::_GETTERS_::
namespace facebook {
  namespace react {
::_MODULES_::
  } // namespace react
} // namespace facebook
`;

function translateReturnTypeToKind(typeAnnotation): string {
  switch (typeAnnotation.type) {
    case 'ReservedFunctionValueTypeAnnotation':
      switch (typeAnnotation.name) {
        case 'RootTag':
          return 'NumberKind';
        default:
          (typeAnnotation.name: empty);
          throw new Error(
            `Invalid ReservedFunctionValueTypeName name, got ${typeAnnotation.name}`,
          );
      }
    case 'VoidTypeAnnotation':
      return 'VoidKind';
    case 'StringTypeAnnotation':
      return 'StringKind';
    case 'BooleanTypeAnnotation':
      return 'BooleanKind';
    case 'NumberTypeAnnotation':
    case 'DoubleTypeAnnotation':
    case 'FloatTypeAnnotation':
    case 'Int32TypeAnnotation':
      return 'NumberKind';
    case 'GenericPromiseTypeAnnotation':
      return 'PromiseKind';
    case 'GenericObjectTypeAnnotation':
    case 'ObjectTypeAnnotation':
      return 'ObjectKind';
    case 'ArrayTypeAnnotation':
      return 'ArrayKind';
    default:
      // TODO (T65847278): Figure out why this does not work.
      // (typeAnnotation.type: empty);
      throw new Error(
        `Unknown prop type for returning value, found: ${typeAnnotation.type}"`,
      );
  }
}

function translateMethodForImplementation(property): string {
  const {returnTypeAnnotation} = property.typeAnnotation;

  const numberOfParams =
    property.typeAnnotation.params.length +
    (returnTypeAnnotation.type === 'GenericPromiseTypeAnnotation' ? 2 : 0);
  const translatedArguments = property.typeAnnotation.params
    .map(param => param.name)
    .concat(
      returnTypeAnnotation.type === 'GenericPromiseTypeAnnotation'
        ? ['resolve', 'reject']
        : [],
    )
    .slice(1)
    .join(':')
    .concat(':');
  if (
    property.name === 'getConstants' &&
    returnTypeAnnotation.type === 'ObjectTypeAnnotation' &&
    returnTypeAnnotation.properties &&
    returnTypeAnnotation.properties.length === 0
  ) {
    return '';
  }
  return propertyTemplate
    .replace(/::_KIND_::/g, translateReturnTypeToKind(returnTypeAnnotation))
    .replace(/::_PROPERTY_NAME_::/g, property.name)
    .replace(
      /::_ARGS_::/g,
      numberOfParams === 0
        ? ''
        : (numberOfParams === 1 ? '' : ':') + translatedArguments,
    );
}

module.exports = {
  generate(
    libraryName: string,
    schema: SchemaType,
    moduleSpecName: string,
  ): FilesOutput {
    const nativeModules: {[name: string]: NativeModuleShape, ...} = Object.keys(
      schema.modules,
    )
      .map(moduleName => {
        const modules = schema.modules[moduleName].nativeModules;
        if (modules == null) {
          return null;
        }

        return modules;
      })
      .filter(Boolean)
      .reduce((acc, modules) => Object.assign(acc, modules), {});

    const gettersImplementations = Object.keys(nativeModules)
      .reduce((acc, moduleName: string) => {
        const module: NativeModuleShape = nativeModules[moduleName];
        return acc.concat(
          flatObjects(
            module.properties
              .reduce((moduleAcc, property) => {
                const {returnTypeAnnotation} = property.typeAnnotation;
                if (returnTypeAnnotation.type === 'ObjectTypeAnnotation') {
                  const {properties} = returnTypeAnnotation;
                  if (properties) {
                    moduleAcc.push({
                      name:
                        'Spec' +
                        capitalizeFirstLetter(property.name) +
                        'ReturnType',
                      object: {
                        type: 'ObjectTypeAnnotation',
                        properties: properties,
                      },
                    });
                  }
                }
                if (property.typeAnnotation.params) {
                  return moduleAcc.concat(
                    property.typeAnnotation.params
                      .map(param => {
                        if (
                          param.typeAnnotation.type === 'ObjectTypeAnnotation'
                        ) {
                          const {properties} = param.typeAnnotation;
                          if (properties) {
                            return {
                              name:
                                'Spec' +
                                capitalizeFirstLetter(property.name) +
                                capitalizeFirstLetter(param.name),
                              object: {
                                type: 'ObjectTypeAnnotation',
                                properties: properties,
                              },
                            };
                          }
                        }
                      })
                      .filter(Boolean),
                  );
                }
                return moduleAcc;
              }, [])
              .concat(
                Object.keys(module.aliases).map(aliasName => {
                  const alias = getTypeAliasTypeAnnotation(
                    aliasName,
                    module.aliases,
                  );
                  return {
                    name: aliasName,
                    object: {type: alias.type, properties: alias.properties},
                  };
                }),
              ),
            false,
            module.aliases,
          )
            .map(object =>
              getterTemplate
                .replace(/::_GETTER_NAME_::/g, object.name)
                .replace(/::_MODULE_NAME_::/g, moduleName),
            )
            .join('\n'),
        );
      }, [])
      .join('\n');

    const modules = Object.keys(nativeModules)
      .map(name => {
        const {aliases, properties} = nativeModules[name];
        const translatedMethods = properties
          .map(property => translateMethodForImplementation(property))
          .join('\n');
        return moduleTemplate
          .replace(/::_TURBOMODULE_METHOD_INVOKERS_::/g, translatedMethods)
          .replace(
            '::_PROPERTIES_MAP_::',
            properties
              .map(
                ({
                  name: propertyName,
                  typeAnnotation: {params, returnTypeAnnotation},
                }) =>
                  propertyName === 'getConstants' &&
                  returnTypeAnnotation.type === 'ObjectTypeAnnotation' &&
                  returnTypeAnnotation.properties &&
                  returnTypeAnnotation.properties.length === 0
                    ? ''
                    : propertyDefTemplate
                        .replace(/::_PROPERTY_NAME_::/g, propertyName)
                        .replace(/::_ARGS_COUNT_::/g, params.length.toString()),
              )
              .join('\n'),
          )
          .replace(
            '::_CONVERSION_SELECTORS_::',
            properties
              .map(({name: propertyName, typeAnnotation: {params}}) =>
                params
                  .map((param, index) => {
                    const typeAnnotation =
                      param.typeAnnotation.type === 'TypeAliasTypeAnnotation'
                        ? getTypeAliasTypeAnnotation(
                            param.typeAnnotation.name,
                            aliases,
                          )
                        : param.typeAnnotation;
                    const selectorName =
                      param.typeAnnotation.type === 'TypeAliasTypeAnnotation'
                        ? param.typeAnnotation.name
                        : 'Spec' +
                          capitalizeFirstLetter(propertyName) +
                          capitalizeFirstLetter(param.name);

                    if (
                      typeAnnotation.type === 'ObjectTypeAnnotation' &&
                      typeAnnotation.properties
                    ) {
                      return argConvertionTemplate
                        .replace('::_SELECTOR_NAME_::', selectorName)
                        .replace('::_ARG_NUMBER_::', index.toString())
                        .replace('::_ARG_NAME_::', propertyName);
                    }

                    return '';
                  })
                  .join(''),
              )
              .join(''),
          )
          .replace(/::_MODULE_NAME_::/g, name);
      })
      .join('\n');

    const fileName = `${moduleSpecName}-generated.mm`;
    const replacedTemplate = template
      .replace(/::_GETTERS_::/g, gettersImplementations)
      .replace(/::_MODULES_::/g, modules)
      .replace(/::_LIBRARY_NAME_::/g, libraryName)
      .replace(/::_INCLUDE_::/g, `${moduleSpecName}/${moduleSpecName}.h`);
    return new Map([[fileName, replacedTemplate]]);
  },
};
