/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#import "RCTTurboModuleManager.h"

#import <cassert>

#import <React/RCTBridgeModule.h>
#import <React/RCTCxxModule.h>
#import <React/RCTLog.h>
#import <jsireact/TurboCxxModule.h>
#import <jsireact/TurboModuleBinding.h>

using namespace facebook;

// Fallback lookup since RCT class prefix is sometimes stripped in the existing NativeModule system.
// This will be removed in the future.
static Class getFallbackClassFromName(const char *name) {
  Class moduleClass = NSClassFromString([NSString stringWithUTF8String:name]);
  if (!moduleClass) {
    moduleClass = NSClassFromString([NSString stringWithFormat:@"RCT%s", name]);
  }
  return moduleClass;
}

@implementation RCTTurboModuleManager
{
  jsi::Runtime *_runtime;
  std::shared_ptr<facebook::react::JSCallInvoker> _jsInvoker;
  std::shared_ptr<react::TurboModuleBinding> _binding;
  __weak id<RCTTurboModuleManagerDelegate> _delegate;
  __weak RCTBridge *_bridge;
}

- (instancetype)initWithRuntime:(jsi::Runtime *)runtime
                         bridge:(RCTBridge *)bridge
                       delegate:(id<RCTTurboModuleManagerDelegate>)delegate
{
  if (self = [super init]) {
    _runtime = runtime;
    _jsInvoker = std::make_shared<react::JSCallInvoker>(bridge.jsMessageThread);
    _delegate = delegate;
    _bridge = bridge;

    __weak __typeof(self) weakSelf = self;
    auto moduleProvider = [weakSelf](const std::string &name) -> std::shared_ptr<react::TurboModule> {
      if (!weakSelf) {
        return nullptr;
      }
      __strong __typeof(self) strongSelf = weakSelf;

      // Pure C++ modules get priority.
      if ([strongSelf->_delegate respondsToSelector:@selector(getTurboModule:jsInvoker:)]) {
        std::shared_ptr<react::TurboModule> tm = [strongSelf->_delegate getTurboModule:name jsInvoker:strongSelf->_jsInvoker];
        if (tm != nullptr) {
          return tm;
        }
      }

      Class moduleClass;
      if ([strongSelf->_delegate respondsToSelector:@selector(getModuleClassFromName:)]) {
        moduleClass = [strongSelf->_delegate getModuleClassFromName:name.c_str()];
      } else {
        moduleClass = getFallbackClassFromName(name.c_str());
      }
      assert(moduleClass);

      id<RCTTurboModule> module;
      if ([strongSelf->_delegate respondsToSelector:@selector(getModuleInstanceFromClass:)]) {
        module = [strongSelf->_delegate getModuleInstanceFromClass:moduleClass];
      } else {
        module = [moduleClass new];
      }

      /**
       * It is reasonable for NativeModules to not want/need the bridge.
       * In such cases, they won't have `@synthesize bridge = _bridge` in their
       * implementation, and a `- (RCTBridge *) bridge { ... }` method won't be
       * generated by the ObjC runtime. The property will also not be backed
       * by an ivar, which makes writing to it unsafe. Therefore, we check if
       * this method exists to know if we can safely set the bridge to the
       * NativeModule.
       */
      if ([module respondsToSelector:@selector(bridge)] && strongSelf->_bridge) {
        /**
         * Just because a NativeModule has the `bridge` method, it doesn't mean
         * that it has synthesized the bridge in its implementation. Therefore,
         * we need to surround the code that sets the bridge to the NativeModule
         * inside a try/catch. This catches the cases where the NativeModule
         * author specifies a `bridge` method manually.
         */
        @try {
          /**
           * RCTBridgeModule declares the bridge property as readonly.
           * Therefore, when authors of NativeModules synthesize the bridge
           * via @synthesize bridge = bridge;, the ObjC runtime generates
           * only a - (RCTBridge *) bridge: { ... } method. No setter is
           * generated, so we have have to rely on the KVC API of ObjC to set
           * the bridge property of these NativeModules.
           */
          [(id)module setValue:strongSelf->_bridge forKey:@"bridge"];
        }
        @catch (NSException *exception) {
          RCTLogError(@"%@ has no setter or ivar for its bridge, which is not "
                      "permitted. You must either @synthesize the bridge property, "
                      "or provide your own setter method.", RCTBridgeModuleNameForClass(module));
        }
      }

      // RCTCxxModule compatibility layer.
      if ([moduleClass isSubclassOfClass:RCTCxxModule.class]) {
        if ([module respondsToSelector:@selector(getTurboModuleWithJsInvoker:)]) {
          return [((id<RCTTurboCxxModule>)module) getTurboModuleWithJsInvoker:strongSelf->_jsInvoker];
        }

        // Use TurboCxxModule compat class to wrap the CxxModule instance.
        // This is only for migration convenience, despite less performant.
        return std::make_shared<react::TurboCxxModule>([((RCTCxxModule *)module) createModule], strongSelf->_jsInvoker);
      }

      return [strongSelf->_delegate getTurboModule:name instance:module jsInvoker:strongSelf->_jsInvoker];
    };

    _binding = std::make_shared<react::TurboModuleBinding>(moduleProvider);
  }
  return self;
}

- (void)installJSBinding
{
  if (!_runtime) {
    // jsi::Runtime doesn't exist when attached to Chrome debugger.
    return;
  }

  react::TurboModuleBinding::install(*_runtime, _binding);
}

- (std::shared_ptr<facebook::react::TurboModule>)getModule:(const std::string &)name
{
  return _binding->getModule(name);
}

@end
